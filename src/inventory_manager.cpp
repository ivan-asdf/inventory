#include <exception>
#include <sstream>
#include <string>
#include <system_error>

#include "inventory_manager.h"
#include "sqlite_orm/sqlite_orm.h"
#include "tabulate.hpp"

const std::string InventoryManager::DB_NAME = "inventory.db";

std::string InventoryManager::SearchFieldToString(SearchField field) {
  switch (field) {
  case Id:
    return std::string("Id");
  case Name:
    return std::string("Name");
  case Quantity:
    return std::string("Quantity");
  case Price:
    return std::string("Price");
  case Supplier:
    return std::string("Supplier");
  default:
    return std::string("(UNKNOWN SEARCH FIELD)");
  }
}

std::string InventoryManager::SearchTypeToString(SearchType type) {
  switch (type) {
  case Equals:
    return std::string("equals");
  case GreaterThan:
    return std::string("greater than");
  case LesserThan:
    return std::string("lesser than");
  default:
    return std::string("(UNKNOWN SEARCH TYPE)");
  }
}

InventoryManager::SearchValue::SearchValue(const char *s) {
  type = Type::String;
  String = s;
}
InventoryManager::SearchValue::SearchValue(int x) {
  type = Type::Integer;
  Integer = x;
}
InventoryManager::SearchValue::SearchValue(double x) {
  type = Type::Double;
  Double = x;
}

std::string InventoryManager::SearchValue::toString() {
  switch (type) {
  case Type::String:
    return std::string("\"") + String + std::string("\"");
  case Type::Integer:
    return std::to_string(Integer);
  case Type::Double:
    return std::to_string(Double);
  }
}

InventoryManager::InventoryManager()
    : storage(make_storage(
          DB_NAME,
          make_table("Inventory", make_column("Id", &Article::id, primary_key().autoincrement()),
                     make_column("Name", &Article::name),
                     make_column("Quantity", &Article::quantity),
                     make_column("Price", &Article::price),
                     make_column("Supplier", &Article::supplier)))) {
  storage.sync_schema();
}

/**
 * @brief Adds a new article to the inventory.
 *
 * This method creates a new article with the specified id, name, quantity, price, and supplier,
 * and inserts it into the database. If an error occurs during the insertion, a nested
 * std::runtime_error is thrown with a detailed error message.
 *
 * @param id The id of the article to be added. If set to <1 an available id will be autogenerated
 * @param name The name of the article.
 * @param quantity The quantity of the article.
 * @param price The price of the article.
 * @param supplier The supplier of the article.
 *
 * @throws std::runtime_error If an error occurs during the insertion into the database.
 * The thrown exception is nested with the original std::system_error.
 *
 * @note If an article with the specified id already exist it will do nothing and print a warning.
 *
 * @code
 * InventoryManager manager;
 * manager.addArticle(1, "Article1", 100, 29.99, "Supplier1");
 * // Adds a new article with id 1, name "Article", quantity 100, price 29.99, and supplier
 * "Supplier1".
 * @endcode
 */
void InventoryManager::addArticle(int id, const std::string &name, int quantity, double price,
                                  const std::string &supplier) {
  Article article{id, name, quantity, price, supplier};

  try {
    if (id >= 1) {
      std::unique_ptr<Article> existingArticle = storage.get_pointer<Article>(id);
      if (existingArticle != nullptr) {
        std::cout << "WARNING(Adding " << article.toString()
                  << " failed): Already existing article with the given id: "
                  << existingArticle->toString() << std::endl;
        return;
      }
      storage.replace(article);
    } else {
      storage.insert(article);
    }
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when creating article " << article.toString() << ": " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  std::cout << "Record created successfully\n";
}

/**
 * @brief Updates an article's information in the inventory.
 *
 * Retrieves the article with the specified ID from database and updates its
 * attributes based on the provided parameters. If any parameter (name, quantity,
 * price, supplier) is provided as non-null or non-negative, the corresponding
 * attribute of the article is updated.
 *
 * @param id The unique identifier of the article to update.
 * @param name The new name of the article (optional). If nullptr, the name remains unchanged.
 * @param quantity The new quantity of the article (optional). Must be non-negative. If negative,
 * quantity remains unchanged.
 * @param price The new price of the article (optional). Must be non-negative. If negative, price
 * remains unchanged.
 * @param supplier The new supplier of the article (optional). If nullptr, the supplier remains
 * unchanged.
 *
 * @throws std::runtime_error If an error occurs during the insertion into the database.
 * The thrown exception is nested with the original std::system_error.
 */
void InventoryManager::updateArticle(int id, const char *name = nullptr, int quantity = -1,
                                     double price = -1, const char *supplier = nullptr) {
  Article article;

  try {
    article = storage.get<Article>(id);
    if (name) {
      article.name = std::string(name);
    }
    if (quantity >= 0) {
      article.quantity = quantity;
    }
    if (price >= 0.0) {
      article.price = price;
    }
    if (supplier) {
      article.supplier = std::string(supplier);
    }
    storage.update(article);
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when updating article with ID " << id << ": " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  std::cout << "Record updated successfully\n";
}

void InventoryManager::deleteArticle(int id) {
  try {
    storage.remove<Article>(id);
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when deliting article with ID " << id << ": " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }
  std::cout << "Record deleted successfully\n";
}

/**
 * @brief Searches articles in the inventory based on the specified search criteria.
 *
 * This method allows searching for articles using different fields such as Id, Name, Quantity,
 * Price, and Supplier. Depending on the field, various search types like Equals, GreaterThan,
 * and LesserThan can be applied.
 *
 * @param field The field of the article to search by. It can be one of the following:
 *              - SearchField::Id
 *              - SearchField::Name
 *              - SearchField::Quantity
 *              - SearchField::Price
 *              - SearchField::Supplier
 *
 * @param type The type of comparison to use for the search. It can be one of the following:
 *             - SearchType::Equals
 *             - SearchType::GreaterThan
 *             - SearchType::LesserThan
 *
 * @param value The value to compare against. The type of this value depends on the field being
 * searched:
 *              - For SearchField::Id and SearchField::Quantity, an integer is expected.
 *              - For SearchField::Price, a double is expected.
 *              - For SearchField::Name and SearchField::Supplier, a string is expected.
 *
 * @throws std::runtime_error If an unknown search type or field is specified, or if there is a
 *                            system error during the search.
 *
 * This method prints the search results in a tabular format to the standard output. The table
 * includes columns for ID, Name, Quantity, Price, and Supplier.
 *
 * @note For string fields(Name, Supplier) only "Equals" search type is available. Which searches if given value is
 * substring of the specified field.
 * @note If an unsupported search params combination is given such as (Name, GreaterThan) a warning will be printed.
 *
 * Example usage:
 * @code
 * InventoryManager manager;
 * SearchValue value;
 * manager.searchArticles(SearchField::Id, SearchType::GreaterThan, SearchValue(5));
 * @endcode
 */
void InventoryManager::searchArticles(SearchField field, SearchType type, SearchValue value) {
  std::vector<Article> articles;

  try {
    switch (field) {
    case SearchField::Id:
      switch (type) {
      case SearchType::Equals:
        articles = storage.get_all<Article>(where(is_equal(&Article::id, value.Integer)));
        break;
      case SearchType::GreaterThan:
        articles = storage.get_all<Article>(where(greater_than(&Article::id, value.Integer)));
        break;
      case SearchType::LesserThan:
        articles = storage.get_all<Article>(where(lesser_than(&Article::id, value.Integer)));
        break;
      default:
        throw std::runtime_error("Unknown search type: " + std::to_string(type));
      }
      break;
    case SearchField::Name:
      switch (type) {
      case SearchType::Equals:
        articles = storage.get_all<Article>(
            where(like(&Article::name, std::string("%") + value.String + std::string("%"))));
        break;
      case SearchType::GreaterThan:
      case SearchType::LesserThan:
        std::cout << "Search combination not supported: " << searchOptionsString(field, type, value)
                  << std::endl;
        break;
      default:
        throw std::runtime_error("Unknown search type: " + std::to_string(type));
      }
      break;
    case SearchField::Quantity:
      switch (type) {
      case SearchType::Equals:
        articles = storage.get_all<Article>(where(is_equal(&Article::quantity, value.Integer)));
        break;
      case SearchType::GreaterThan:
        articles = storage.get_all<Article>(where(greater_than(&Article::quantity, value.Integer)));
        break;
      case SearchType::LesserThan:
        articles = storage.get_all<Article>(where(lesser_than(&Article::quantity, value.Integer)));
        break;
      default:
        throw std::runtime_error("Unknown search type: " + std::to_string(type));
      }
      break;
    case SearchField::Price:
      switch (type) {
      case SearchType::Equals:
        articles = storage.get_all<Article>(where(is_equal(&Article::price, value.Double)));
        break;
      case SearchType::GreaterThan:
        articles = storage.get_all<Article>(where(greater_than(&Article::price, value.Double)));
        break;
      case SearchType::LesserThan:
        articles = storage.get_all<Article>(where(lesser_than(&Article::price, value.Double)));
        break;
      default:
        throw std::runtime_error("Unknown search type: " + std::to_string(type));
      }
      break;
    case SearchField::Supplier:
      switch (type) {
      case SearchType::Equals:
        articles = storage.get_all<Article>(
            where(like(&Article::supplier, std::string("%") + value.String + std::string("%"))));
        break;
      case SearchType::GreaterThan:
      case SearchType::LesserThan:
        std::cout << "Search combination not supported: " << searchOptionsString(field, type, value)
                  << std::endl;
        break;
      default:
        throw std::runtime_error("Unknown search type: " + std::to_string(type));
      }
      break;
    default:
      throw std::runtime_error("Unknown search field: " + std::to_string(field));
    }
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when searching articles : " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  Table root;

  root.add_row({"Search Results"});
  root[0].format().font_align(FontAlign::center).font_style({FontStyle::bold});

  root.add_row({searchOptionsString(field, type, value)});
  root[1].format().font_align(FontAlign::center).font_style({FontStyle::bold});

  Table table;
  table.add_row({"ID", "Name", "Quantity", "Price", "Supplier"});
  for (const Article &article : articles) {
    table.add_row({std::to_string(article.id), article.name, std::to_string(article.quantity),
                   std::to_string(article.price), article.supplier});
  }
  root.add_row({table});

  std::cout << root << std::endl;
}

/**
 * @brief Generates and prints a report of all articles in the inventory.
 *
 * Retrieves all articles from database, constructs a formatted table
 * containing article details including ID, name, quantity, price,
 * and supplier information. Computes summary statistics such as
 * total number of articles, total quantity across all articles,
 * and total price of all articles. Outputs the report to the console
 * in a structured format.
 *
 * @throws std::runtime_error If an error occurs during the insertion into the database.
 * The thrown exception is nested with the original std::system_error.
 */
void InventoryManager::generateReport() {
  std::vector<Article> articles;

  try {
    articles = storage.get_all<Article>();
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when generating report: " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  Table root;

  root.add_row({"Report"});
  root[0].format().font_align(FontAlign::center).font_style({FontStyle::bold});

  Table articlesTable;
  articlesTable.add_row({"ID", "Name", "Quantity", "Price", "Supplier"});
  int totalCount = 0, totalQuantity = 0;
  double totalPrice = 0.0;
  for (const Article &article : articles) {
    articlesTable.add_row({std::to_string(article.id), article.name,
                           std::to_string(article.quantity), std::to_string(article.price),
                           article.supplier});
    totalCount++;
    totalQuantity += article.quantity;
    totalPrice += article.price;
  }
  root.add_row({articlesTable});

  Table summaryTable;
  summaryTable.add_row({"Total Articles Count", "Total Quantity", "Total Price"});
  summaryTable.add_row(
      {std::to_string(totalCount), std::to_string(totalQuantity), std::to_string(totalPrice)});
  root.add_row({summaryTable});
  root[2].format().font_align(FontAlign::center).font_style({FontStyle::bold});

  std::cout << root << std::endl;
}

std::string InventoryManager::searchOptionsString(SearchField field, SearchType type,
                                                  SearchValue value) {
  std::stringstream ss;
  ss << SearchFieldToString(field) << " " << SearchTypeToString(type) << " " << value.toString();
  return ss.str();
}
