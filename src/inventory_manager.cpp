#include <exception>
#include <sstream>
#include <string>
#include <system_error>

#include "inventory_manager.h"
#include "tabulate.hpp"

const std::string InventoryManager::DB_NAME = "inventory.db";

InventoryManager::InventoryManager()
    : storage(make_storage(
          DB_NAME,
          make_table("Inventory", make_column("Id", &Article::id, primary_key().autoincrement()),
                     make_column("Name", &Article::name),
                     make_column("Quantity", &Article::quantity),
                     make_column("Price", &Article::price),
                     make_column("Supplier", &Article::supplier)))) {
  storage.sync_schema();
}

/**
 * @brief Adds a new article to the inventory.
 *
 * This method creates a new article with the specified id, name, quantity, price, and supplier,
 * and inserts it into the database. If an error occurs during the insertion, a nested
 * std::runtime_error is thrown with a detailed error message.
 *
 * @param id The id of the article to be added. If set to <1 an available id will be autogenerated
 * @param name The name of the article.
 * @param quantity The quantity of the article.
 * @param price The price of the article.
 * @param supplier The supplier of the article.
 *
 * @throws std::runtime_error If an error occurs during the insertion into the database.
 * The thrown exception is nested with the original std::system_error.
 *
 * @note If an article with the specified id already exist it will do nothing and print a warning.
 *
 * @code
 * InventoryManager manager;
 * manager.addArticle(1, "Article1", 100, 29.99, "Supplier1");
 * // Adds a new article with id 1, name "Article", quantity 100, price 29.99, and supplier
 * "Supplier1".
 * @endcode
 */
void InventoryManager::addArticle(int id, const std::string &name, int quantity, double price,
                                  const std::string &supplier) {
  Article article{id, name, quantity, price, supplier};

  try {
    if (id >= 1) {
      std::unique_ptr<Article> existingArticle = storage.get_pointer<Article>(id);
      if (existingArticle != nullptr) {
        std::cout << "WARNING(Adding " << article.toString()
                  << " failed): Already existing article with the given id: "
                  << existingArticle->toString() << std::endl;
        return;
      }
      storage.replace(article);
    } else {
      storage.insert(article);
    }
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when creating article " << article.toString() << ": " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  std::cout << "Record created successfully\n";
}

void InventoryManager::updateArticle(int id, int quantity, double price) {
  Article article;

  try {
    article = storage.get<Article>(id);
    article.quantity = quantity;
    article.price = price;
    storage.update(article);
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when updating article with ID " << id << ": " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  std::cout << "Record updated successfully\n";
}

void InventoryManager::deleteArticle(int id) {
  try {
    storage.remove<Article>(id);
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when deliting article with ID " << id << ": " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }
  std::cout << "Record deleted successfully\n";
}

void InventoryManager::searchArticles(const std::string &criteria) {
  std::vector<Article> articles;

  try {
    articles = storage.get_all<Article>(
        where(like(&Article::name, criteria) or like(&Article::supplier, criteria)));
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when searching articles : " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  Table table;
  table.add_row({"ID", "Name", "Quantity", "Price", "Supplier"});
  for (const Article &article : articles) {
    table.add_row({std::to_string(article.id), article.name, std::to_string(article.quantity),
                   std::to_string(article.price), article.supplier});
  }

  std::cout << "Search results:\n";
  std::cout << table << std::endl;
}

/**
 * @brief Generates and prints a report of all articles in the inventory.
 *
 * Retrieves all articles from database, constructs a formatted table
 * containing article details including ID, name, quantity, price,
 * and supplier information. Computes summary statistics such as
 * total number of articles, total quantity across all articles,
 * and total price of all articles. Outputs the report to the console
 * in a structured format.
 *
 * @throws std::runtime_error If an error occurs during the insertion into the database.
 * The thrown exception is nested with the original std::system_error.
 */
void InventoryManager::generateReport() {
  std::vector<Article> articles;

  try {
    articles = storage.get_all<Article>();
  } catch (const std::system_error e) {
    std::stringstream errorMsg;
    errorMsg << "Error when generating report: " << e.what();
    std::throw_with_nested(std::runtime_error(errorMsg.str()));
  }

  Table root;

  root.add_row({"Report"});
  root[0].format().font_align(FontAlign::center).font_style({FontStyle::bold});

  Table articlesTable;
  articlesTable.add_row({"ID", "Name", "Quantity", "Price", "Supplier"});
  int totalCount = 0 , totalQuantity = 0;
  double totalPrice = 0.0;
  for (const Article &article : articles) {
    articlesTable.add_row({std::to_string(article.id), article.name, std::to_string(article.quantity),
                   std::to_string(article.price), article.supplier});
    totalCount++;
    totalQuantity+=article.quantity;
    totalPrice+=article.price;
  }
  root.add_row({articlesTable});

  Table summaryTable;
  summaryTable.add_row({"Total Articles Count", "Total Quantity", "Total Price"});
  summaryTable.add_row({std::to_string(totalCount), std::to_string(totalQuantity), std::to_string(totalPrice)});
  root.add_row({summaryTable});
  root[2].format().font_align(FontAlign::center).font_style({FontStyle::bold});

  std::cout << root << std::endl;
}
